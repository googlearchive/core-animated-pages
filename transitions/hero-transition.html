<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link href="core-pages-transition.html" rel="import">

<!--

`hero-transition` transforms two elements in different pages during a page transition such
that they appear to be the same element. The elements should set both the `hero` and `hero-id`
attributes. Elements with the same `hero-id` in different pages are matched and appear to scale
and translate between the two positions as a single element.

Because it is common to share elements with different `border-radius` values, by default this
transition will also animate the the `border-radius property.

You can configure the duration of the hero transition with the global variable
`CoreStyle.g.transitions.heroDuration`.

Example:

    <core-animated-pages transition="hero-transition">
      <section layout horizontal>
        <div id="div1" flex></div>
        <div id="div2" flex hero-id="shared" hero></div>
      </section>
      <section layout horizontal>
        <div id="div3" flex hero-id="shared" hero></div>
        <div id="div4" flex></div>
      </section>
      </section>
    </core-animated-pages>

In the above example, the elements `#div2` and `#div3` appears to scale and translate
as a single element during a page transition.

@class hero-transition
@extends core-transition-pages
@status beta
@homepage github.io
-->

<polymer-element name="hero-transition" extends="core-pages-transition">
<script>
(function() {

  var webkitStyles = '-webkit-transition' in document.documentElement.style
  var TRANSITION_CSSNAME = webkitStyles ? '-webkit-transition' : 'transition';
  var TRANSFORM_CSSNAME = webkitStyles ? '-webkit-transform' : 'transform';
  var TRANSITION_NAME = webkitStyles ? 'webkitTransition' : 'transition';
  var TRANSFORM_NAME = webkitStyles ? 'webkitTransform' : 'transform';

  var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;

  Polymer({

    setup: function(scope, options) {
      var src = options.src, dst = options.dst;
      var anims = [];

      // FIXME(yvonne): basic support for nested pages.
      // Look for heroes in the light DOM and one level of shadow DOM of the src and dst,
      // and also in src.selectedItem or dst.selectedItem, then transform the dst hero to src
      var ss = '[hero]';
      var h$ = this.findAllInShadows(src, ss);
      if (src.selectedItem) {
        hs$ = this.findAllInShadows(src.selectedItem, ss);
        hsa$ = [];
        // De-duplicate items
        Array.prototype.forEach.call(hs$, function(hs) {
          if (h$.indexOf(hs) === -1) {
            hsa$.push(hs);
          }
        })
        h$ = h$.concat(hsa$);
      }

      for (var i=0, h0; h0=h$[i]; i++) {
        var v = h0.getAttribute('hero-id');
        var ds = '[hero][hero-id="' + v + '"]';

        // Find matching hero in dst
        var h1 = this.findInShadows(dst, ds);
        if (!h1 && dst.selectedItem) {
          h1 = this.findInShadows(dst.selectedItem, ds);
        }

        // console.log('src', src);
        // console.log('dst', dst, dst.selectedItem);
        // console.log(v, h0, h1);

        // Measure
        if (v && h1) {
          var c0 = getComputedStyle(h0);
          var c1 = getComputedStyle(h1);
          var h = {
            h0: h0,
            b0: h0.getBoundingClientRect(),
            r0: c0.borderRadius,
            h1: h1,
            b1: h1.getBoundingClientRect(),
            r1: c1.borderRadius
          };

          var dl = h.b0.left - h.b1.left;
          var dt = h.b0.top - h.b1.top;
          var sw = h.b0.width / h.b1.width;
          var sh = h.b0.height / h.b1.height;

          h.h1.style[TRANSFORM_NAME + 'Origin'] = '0 0';

          // Transform the dst hero to dimensions of src
          anims.push(new Animation(h.h1, [
            {'transform': 'translate(' + dl + 'px,' + dt + 'px)' + ' scale(' + sw + ',' + sh + ')', 'border-radius': h.r0, 'z-index': 10000},
            {'transform': 'none', 'border-radius': h.r1, 'z-index': 10000}
          ], this.timingForNode(h.h1)));

          // Hide the src hero
          anims.push(new Animation(h.h0, [
            {'visibility': 'hidden'},
            {'visibility': 'hidden'}
          ], this.timingForNode(h.h0)));
        }
      }

      if (anims.length) {
        this.animation = new AnimationGroup(anims);
      } else {
        this.animation = null;
      }
      return this.animation;
    }

  });

})();
</script>
</polymer-element>

<hero-transition id="hero-transition"></hero-transition>
